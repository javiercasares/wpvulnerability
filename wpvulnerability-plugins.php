<?php
/**
 * Plugin functions
 *
 * @package WPVulnerability
 *
 * @version 2.0.0
 */

defined( 'ABSPATH' ) || die( 'No script kiddies please!' );

/**
 * Adds a vulnerability notice under vulnerable plugins.
 *
 * @since 2.0.0
 *
 * @param  string $plugin_file Main plugin folder/file name.
 * @param  array  $plugin_data Plugin data.
 *
 * @return void
 */
function wpvulnerability_plugin_info_after( $plugin_file, $plugin_data ) {

	// Retrieve the vulnerabilities for all plugins from the options table and decode the JSON.
	if ( is_multisite() ) {
		$plugin_vulnerabilities = json_decode( get_site_option( 'wpvulnerability-plugins' ), true );
	} elseif ( ! is_multisite() ) {
		$plugin_vulnerabilities = json_decode( get_option( 'wpvulnerability-plugins' ), true );
	}

	// Determine whether the plugin is active and add an appropriate CSS class to the table row.
	$tr_class = '';
	if ( is_plugin_active( $plugin_file ) ) {
		$tr_class .= 'active';
	}

	// Generate the vulnerability notice message with the plugin name.
	$message = sprintf(
		/* translators: 1: Plugin name */
		__( '%1$s has a known vulnerability that may be affecting this version.', 'wpvulnerability' ),
		wp_kses( $plugin_data['Name'], 'strip' )
	);

	// Begin generating the table row HTML markup with appropriate CSS classes and the vulnerability notice message.
	$information  = '<tr class="wpvulnerability ' . $tr_class . '">';
	$information .= '<td colspan="4">';
	$information .= '<p class="text-red"><img src="' . esc_url( WPVULNERABILITY_PLUGIN_URL ) . 'assets/logo16.png" style="height: 16px; vertical-align: text-top; width: 16px;" alt="" title="WPVulnerability"> <strong>' . $message . '</strong>';
	$information .= '</p>';
	$information .= '<table>';

	// Loop through all vulnerabilities for the current plugin and add their details to the table row HTML markup.
	$vulnerabilities = $plugin_vulnerabilities[ $plugin_file ]['vulnerabilities'];

	foreach ( $vulnerabilities as $vulnerability ) {

		$what = array();
		if ( isset( $vulnerability['impact']['cwe'] ) ) {
			foreach ( $vulnerability['impact']['cwe'] as $vulnerability_cwe ) {
				$what[] = '<div><b>' . wp_kses( $vulnerability_cwe['name'], 'strip' ) . '</b></div><div><i>' . wp_kses_post( $vulnerability_cwe['description'] ) . '</i></div>';
			}
		}

		$sources = array();
		if ( isset( $vulnerability['source'] ) ) {
			foreach ( $vulnerability['source'] as $vulnerability_source ) {
				$sources[] = '<a href="' . esc_url_raw( $vulnerability_source['link'], 'strip' ) . '" target="_blank" rel="external nofollow noopener noreferrer">[+]</a>&nbsp;' . wp_kses( $vulnerability_source['name'], 'strip' );
			}
		}
		if ( count( $sources ) ) {
			$source = '<div style="padding-bottom: 5px;">' . implode( '<br>', $sources ) . '</div>';
		}

		$score = null;
		if ( isset( $vulnerability['impact']['cvss']['score'] ) ) {
			$score = number_format( (float) $vulnerability['impact']['cvss']['score'], 1, '.', '' );
		}
		$severity = null;
		if ( isset( $vulnerability['impact']['cvss']['severity'] ) ) {
			$severity = wpvulnerability_severity( $vulnerability['impact']['cvss']['severity'] );
		}
		$exploitable = null;
		if ( isset( $vulnerability['impact']['cvss']['exploitable'] ) ) {
			$exploitable = number_format( (float) $vulnerability['impact']['cvss']['exploitable'], 1, '.', '' );
		}

		$information .= '<tr>';
		$information .= '<td style="max-width: 256px; min-width: 96px;"><b>' . wp_kses( $vulnerability['versions'], 'strip' ) . '</b></td>';
		$information .= '<td>';
		if ( (int) $vulnerability['closed'] || (int) $vulnerability['unfixed'] ) {
			$information .= '<div style="padding-bottom: 5px;">';
			if ( (int) $vulnerability['closed'] ) {
				$information .= '<div class="text-red">' . __( 'This plugin is closed. Please replace it with another.', 'wpvulnerability' ) . '</div>';
			}
			if ( (int) $vulnerability['unfixed'] ) {
				$information .= '<div class="text-red">' . __( 'This vulnerability appears to be unpatched. Stay tuned for upcoming plugin updates.', 'wpvulnerability' ) . '</div>';
			}
			$information .= '</div>';
		}
		if ( count( $what ) ) {
			$information .= '<div style="padding-bottom: 5px;">';
			foreach ( $what as $w ) {
				$information .= $w;
			}
			$information .= '</div>';
		}
		if ( ! is_null( $score ) || ! is_null( $severity ) || ! is_null( $exploitable ) ) {
			$information .= '<div style="padding-bottom: 5px;">';
			if ( ! is_null( $score ) ) {
				$information .= '<div>' . __( 'Global score: ', 'wpvulnerability' ) . $score . ' / 10</div>';
			}
			if ( ! is_null( $severity ) ) {
				$information .= '<div>' . __( 'Severity: ', 'wpvulnerability' ) . $severity . '</div>';
			}
			if ( ! is_null( $exploitable ) ) {
				$information .= '<div>' . __( 'Exploitability: ', 'wpvulnerability' ) . $exploitable . ' / 10</div>';
			}
			$information .= '</div>';
		}
		$information .= wp_kses( $source, 'post' );
		$information .= '</td>';
		$information .= '</tr>';

	}

	$information .= '</table>';
	$information .= '</td>';
	$information .= '</tr>';

	echo $information; // phpcs:ignore
}

/**
 * Retrieves vulnerabilities for a given plugin and updates its data.
 *
 * @since 2.0.0
 *
 * @param array  $plugin_data The plugin data array.
 * @param string $file_path The path to the plugin file.
 *
 * @return array The updated plugin data array.
 */
function get_fresh_plugin_vulnerabilities( $plugin_data, $file_path ) {

	$plugin_slug = null;

	// Extract it from the file path.
	$folder_name = explode( '/', $file_path );

	// If not, use the TextDomain key.
	if ( isset( $folder_name[0] ) ) {
		$plugin_slug = wp_kses( trim( (string) $folder_name[0] ), 'strip' );
	}
	unset( $folder_name );

	// If the TextDomain key is empty, extract it from the file path.
	if ( is_null( $plugin_slug ) ) {
		$plugin_slug = wp_kses( $plugin_data['TextDomain'], 'strip' );
	}

	// Get the plugin slug and version from the plugin data.
	$plugin_version = wp_kses( $plugin_data['Version'], 'strip' );

	// Initialize vulnerability related fields.
	$plugin_data['vulnerabilities'] = null;
	$plugin_data['vulnerable']      = 0;

	// Retrieve vulnerabilities for the plugin using its slug and version.
	if ( $plugin_slug ) {

		$plugin_api_response = wpvulnerability_get_plugin( $plugin_slug, $plugin_version );

		// If vulnerabilities are found, update the plugin data accordingly.
		if ( ! empty( $plugin_api_response ) ) {

			$plugin_data['vulnerabilities'] = $plugin_api_response;
			$plugin_data['vulnerable']      = 1;

		}
	}

	return $plugin_data;
}

/**
 * Retrieves updated data for a specified plugin, potentially including vulnerability information.
 *
 * @since 3.1.0
 *
 * @param array  $plugin_data The original plugin data array, expected to contain keys like 'TextDomain' and 'Version'.
 * @param string $file_path   The file path of the plugin, used to determine the plugin's slug if 'TextDomain' is not specified in `$plugin_data`.
 *
 * @return array|null Updated plugin data array with fresh information or null if the plugin slug cannot be determined or no updated information is available.
 */
function get_fresh_plugin_data( $plugin_data, $file_path ) {

	$plugin_slug = null;

	// Extract it from the file path.
	$folder_name = explode( '/', $file_path );

	// If not, use the TextDomain key.
	if ( isset( $folder_name[0] ) ) {
		$plugin_slug = wp_kses( trim( (string) $folder_name[0] ), 'strip' );
	}
	unset( $folder_name );

	// If the TextDomain key is empty, extract it from the file path.
	if ( is_null( $plugin_slug ) ) {
		$plugin_slug = wp_kses( $plugin_data['TextDomain'], 'strip' );
	}

	// Get the plugin slug and version from the plugin data.
	$plugin_version = wp_kses( $plugin_data['Version'], 'strip' );

	// Retrieve vulnerabilities for the plugin using its slug and version.
	if ( $plugin_slug ) {

		$plugin_api_response = wpvulnerability_get_plugin( $plugin_slug, 0, 1 );

		// If vulnerabilities are found, update the plugin data accordingly.
		if ( ! empty( $plugin_api_response ) ) {

			return $plugin_api_response;

		}
	}

	return null;
}

/**
 * Get Installed Plugins
 * Retrieves the list of installed plugins, checks for vulnerabilities in each of them, caches the data, and sends an email notification if vulnerabilities are detected.
 *
 * @since 2.0.0
 *
 * @return string JSON-encoded array of plugin data with vulnerabilities and vulnerable status
 */
function wpvulnerability_plugin_get_installed() {

	$wpvulnerability_plugins_vulnerable = 0;

	if ( ! function_exists( 'get_plugins' ) ) {
		require_once ABSPATH . 'wp-admin/includes/plugin.php';
	}

	$plugins = get_plugins();

	foreach ( $plugins as $file_path => $plugin_data ) {

		$plugins[ $file_path ] = get_fresh_plugin_vulnerabilities( $plugin_data, $file_path );

		if ( isset( $plugins[ $file_path ]['vulnerable'] ) && (int) $plugins[ $file_path ]['vulnerable'] ) {

			++$wpvulnerability_plugins_vulnerable;

		}
	}

	if ( is_multisite() ) {

		update_site_option( 'wpvulnerability-plugins', wp_json_encode( $plugins ) );
		update_site_option( 'wpvulnerability-plugins-vulnerable', wp_json_encode( number_format( $wpvulnerability_plugins_vulnerable, 0, '.', '' ) ) );

	} elseif ( ! is_multisite() ) {

		update_option( 'wpvulnerability-plugins', wp_json_encode( $plugins ) );
		update_option( 'wpvulnerability-plugins-vulnerable', wp_json_encode( number_format( $wpvulnerability_plugins_vulnerable, 0, '.', '' ) ) );

	}

	return wp_json_encode( $plugins );
}

/**
 * Retrieves and caches data for all installed plugins, optionally refreshing the cache.
 *
 * @since 3.1.0
 *
 * @param bool $clean Optional. Whether to force a refresh of the plugin data cache. Default false.
 *
 * @return string JSON-encoded array of updated plugin data. Each plugin is represented by its file path as the key and its updated data as the value.
 */
function wpvulnerability_plugin_get_data( $clean = false ) {

	if ( is_multisite() ) {

		// Get the cached plugin data and decode it.
		$plugin_data_cache = json_decode( get_site_option( 'wpvulnerability-plugins-cache-data' ) );

		// Get the installed plugin data and decode it.
		$plugin_data = json_decode( get_site_option( 'wpvulnerability-plugins-data' ), true );

	} elseif ( ! is_multisite() ) {

		// Get the cached plugin data and decode it.
		$plugin_data_cache = json_decode( get_option( 'wpvulnerability-plugins-cache-data' ) );

		// Get the installed plugin data and decode it.
		$plugin_data = json_decode( get_option( 'wpvulnerability-plugins-data' ), true );

	}

	if ( $plugin_data_cache < time() || empty( $plugin_data ) || $clean ) {

		if ( ! function_exists( 'get_plugins' ) ) {
			require_once ABSPATH . 'wp-admin/includes/plugin.php';
		}

		$plugins = get_plugins();

		$pluginsdata = array();

		foreach ( $plugins as $file_path => $plugin_data ) {

			$pluginsdata[ $file_path ] = get_fresh_plugin_data( $plugin_data, $file_path );

		}

		if ( is_multisite() ) {

			update_site_option( 'wpvulnerability-plugins-data', wp_json_encode( $pluginsdata ) );
			update_site_option( 'wpvulnerability-plugins-cache-data', wp_json_encode( number_format( time() + ( 3600 * WPVULNERABILITY_CACHE_HOURS ), 0, '.', '' ) ) );

		} elseif ( ! is_multisite() ) {

			update_option( 'wpvulnerability-plugins-data', wp_json_encode( $pluginsdata ) );
			update_option( 'wpvulnerability-plugins-cache-data', wp_json_encode( number_format( time() + ( 3600 * WPVULNERABILITY_CACHE_HOURS ), 0, '.', '' ) ) );

		}
	}

	return wp_json_encode( $pluginsdata );
}

/**
 * Get the cached plugin vulnerabilities or update the cache if it's stale or missing.
 *
 * @since 2.0.0
 *
 * @return array Array of installed plugins with their vulnerabilities.
 */
function wpvulnerability_plugin_get_vulnerabilities() {

	if ( is_multisite() ) {

		// Get the cached plugin data and decode it.
		$plugin_data_cache = json_decode( get_site_option( 'wpvulnerability-plugins-cache' ) );

		// Get the installed plugin data and decode it.
		$plugin_data = json_decode( get_site_option( 'wpvulnerability-plugins' ), true );

	} elseif ( ! is_multisite() ) {

		// Get the cached plugin data and decode it.
		$plugin_data_cache = json_decode( get_option( 'wpvulnerability-plugins-cache' ) );

		// Get the installed plugin data and decode it.
		$plugin_data = json_decode( get_option( 'wpvulnerability-plugins' ), true );

	}

	// If the cache is stale or the plugin data is empty, update the cache.
	if ( $plugin_data_cache < time() || empty( $plugin_data ) ) {

		// Get the installed plugin data and update the cache.
		$plugin_data = json_decode( wpvulnerability_plugin_get_installed(), true );

		if ( is_multisite() ) {

			update_site_option( 'wpvulnerability-plugins-cache', wp_json_encode( number_format( time() + ( 3600 * WPVULNERABILITY_CACHE_HOURS ), 0, '.', '' ) ) );

		} elseif ( ! is_multisite() ) {

			update_option( 'wpvulnerability-plugins-cache', wp_json_encode( number_format( time() + ( 3600 * WPVULNERABILITY_CACHE_HOURS ), 0, '.', '' ) ) );

		}
	}

	return $plugin_data;
}

/**
 * Update the installed plugins cache and remove any old cache data
 *
 * @since 2.0.0
 *
 * @return void
 */
function wpvulnerability_plugin_get_vulnerabilities_clean() {

	// Update the installed plugins cache.
	wpvulnerability_plugin_get_installed();

	if ( is_multisite() ) {

		update_site_option( 'wpvulnerability-plugins-cache', wp_json_encode( number_format( time() + ( 3600 * WPVULNERABILITY_CACHE_HOURS ), 0, '.', '' ) ) );

	} elseif ( ! is_multisite() ) {

		update_option( 'wpvulnerability-plugins-cache', wp_json_encode( number_format( time() + ( 3600 * WPVULNERABILITY_CACHE_HOURS ), 0, '.', '' ) ) );

	}

	// Update the plugins data cache.
	wpvulnerability_plugin_get_data( true );
}

/**
 * Displays information in the 'Last Updated' column for each plugin in the plugins list table.
 *
 * This function is triggered for each row in the plugins list table when the 'Last Updated' column is rendered. It retrieves the last update date from stored plugin data, compares it against the current date to highlight plugins not updated in over a year or those marked as closed, and displays this information.
 *
 * @since 3.1.0 Introduced.
 *
 * @param string $column_name The name of the current column being rendered.
 * @param string $plugin_file Path to the plugin file, relative to the plugins directory.
 * @param array  $plugin_data Array of plugin data, such as the plugin's name, version, and description.
 *
 * @return void Outputs the last updated information directly to the browser, including any warnings for plugins not updated in over a year or marked as closed.
 */
function wpvulnerability_plugin_show_lastupdated( $column_name, $plugin_file, $plugin_data ) {

	$now  = time();
	$year = strtotime( '-1 year', $now );

	if ( 'last_updated' === $column_name ) {

		$plugin_slug = null;

		// Extract it from the file path.
		$folder_name = explode( '/', $plugin_file );

		// If not, use the TextDomain key.
		if ( isset( $folder_name[0] ) ) {
			$plugin_slug = wp_kses( trim( (string) $folder_name[0] ), 'strip' );
		}
		unset( $folder_name );

		// If the TextDomain key is empty, extract it from the file path.
		if ( is_null( $plugin_slug ) ) {
			$plugin_slug = wp_kses( $plugin_data['TextDomain'], 'strip' );
		}

		if ( isset( $plugin_slug ) ) {

			// Retrieve the vulnerabilities for all plugins from the options table and decode the JSON.
			if ( is_multisite() ) {
				$plugins_data = json_decode( get_site_option( 'wpvulnerability-plugins-data' ), true );
			} elseif ( ! is_multisite() ) {
				$plugins_data = json_decode( get_option( 'wpvulnerability-plugins-data' ), true );
			}

			// Loop through all vulnerabilities for the current plugin and add their details to the table row HTML markup.
			$plugin_data = $plugins_data[ $plugin_file ];

			if ( isset( $plugin_data['latest'] ) && (int) $plugin_data['latest'] > 0 ) {

				$plugin_data_updated = wp_date( get_option( 'date_format' ), (int) $plugin_data['latest'] );

				$plugin_data_ago = human_time_diff( (int) $plugin_data['latest'] );

				$warning_date = false;

				if ( (int) $plugin_data['latest'] < $year ) {

					$warning_date = true;

				}

				$warning_closed = false;

				if ( isset( $plugin_data['closed'] ) && (int) $plugin_data['closed'] ) {

					$warning_closed = true;

				}

				echo '<p>' . wp_kses( $plugin_data_updated, 'strip' ) . ' (' . wp_kses( $plugin_data_ago, 'strip' ) . ')</p>';

				if ( $warning_date ) {

					echo '<p><strong>⚠️ ';
					e_( 'It hasn\'t been updated in over a year.', 'wpvulnerability' );
					echo '</strong></p>';

				}

				if ( $warning_closed ) {

					echo '<p><strong>⚠️ ';
					e_( 'It may no longer be available (closed?).', 'wpvulnerability' );
					echo '</strong></p>';

				}
			} else {

				echo '<p></p>';

			}
		}
	}
}

/**
 * Adds a 'Last Updated' column to the plugins table list in the WordPress admin area.
 *
 * This function iterates over the existing columns in the plugins table and inserts a new column titled 'Last Updated' just before the 'auto-updates' column if it exists. If the 'auto-updates' column is not found, the 'Last Updated' column is appended at the end. The function is typically hooked to the 'manage_plugins_columns' filter in WordPress to modify the columns of the plugins table.
 *
 * @since 3.1.0 Introduced.
 *
 * @param array $columns An associative array of column names and titles for the plugins table.
 *
 * @return array An associative array containing the modified list of columns, including the new 'Last Updated' column.
 */
function wpvulnerability_plugin_add_lastupdated_column( $columns ) {

	$toadd       = true;
	$new_columns = array();

	// Loop through each existing column and add it to the new columns array.
	foreach ( $columns as $key => $title ) {

		// Insert your custom column before the 'auto-updates' column.
		if ( 'auto-updates' === $key && $toadd ) {
			$new_columns['last_updated'] = __( 'Last updated on', 'wpvulnerability' );
			$toadd                       = false;
		}

		// Add the existing column to the new columns array.
		$new_columns[ $key ] = $title;
	}

	if ( ! $toadd ) {
		$new_columns['last_updated'] = __( 'Last updated on', 'wpvulnerability' );
		$toadd                       = true;
	}

	// Return the modified columns array.
	return $new_columns;
}

/**
 * Admin Head
 * Adds vulnerability information after the plugin row and notices on the plugin page based on the installed plugins cache
 *
 * @since 2.0.0
 *
 * @return void
 */
function wpvulnerability_plugin_page() {

	// Check if the current page is the plugins page.
	global $pagenow;

	if (
		'plugins.php' === $pagenow &&
		(
			( is_multisite() && is_network_admin() && current_user_can( 'manage_network' ) ) ||
			( ! is_multisite() && is_admin() && current_user_can( 'manage_options' ) )
		)
	) {

		// Get the vulnerabilities for the installed plugins.
		$plugins = wpvulnerability_plugin_get_vulnerabilities();

		// Loop through the plugins and add vulnerability information after the plugin row for vulnerable plugins.
		foreach ( $plugins as $file_path => $plugin_data ) {

			if ( isset( $plugin_data['vulnerable'] ) && 1 === $plugin_data['vulnerable'] ) {

				add_action( 'after_plugin_row_' . $file_path, 'wpvulnerability_plugin_info_after', 10, 3 );

			}
		}

		if ( is_multisite() && is_network_admin() && current_user_can( 'manage_network' ) ) {

			add_filter( 'manage_plugins-network_columns', 'wpvulnerability_plugin_add_lastupdated_column' );

		} elseif ( ! is_multisite() && is_admin() && current_user_can( 'manage_options' ) ) {

			add_filter( 'manage_plugins_columns', 'wpvulnerability_plugin_add_lastupdated_column' );

		}

		add_filter( 'manage_plugins_custom_column', 'wpvulnerability_plugin_show_lastupdated', 10, 3 );

	}
}
// Add notices for vulnerable plugins on the plugin page.
add_action( 'admin_head', 'wpvulnerability_plugin_page' );
